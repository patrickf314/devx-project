package de.devx.project.client.react;

import de.devx.project.client.react.properties.ReactClientGeneratorProperties;
import de.devx.project.commons.client.typescript.data.TypeScriptPathModel;
import de.devx.project.commons.client.typescript.data.TypeScriptServiceMethodModel;
import de.devx.project.commons.client.typescript.data.TypeScriptServiceModel;
import de.devx.project.commons.client.typescript.data.TypeScriptTypeModel;
import de.devx.project.commons.client.typescript.properties.TypeScriptDependency;
import de.devx.project.commons.test.io.TestSourceFileGenerator;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.Collections;
import java.util.List;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.Is.is;

class ReactClientGeneratorTest {

    private final TestSourceFileGenerator fileGenerator = new TestSourceFileGenerator();
    private final ReactClientGenerator generator = new ReactClientGenerator(fileGenerator, new ReactClientGeneratorProperties(
            List.of(),
            List.of(),
            null,
            new TypeScriptDependency("testErrorMapper", "commons/service-commons.ts"),
            new TypeScriptDependency("testErrorSerializer", "commons/service-commons.ts"),
            new TypeScriptDependency("testThunkConfig", "commons/service-commons.ts"),
            new TypeScriptDependency("testPrepareHeaders", "auth/user-authenticator.ts"),
            null,
            "http://localhost:8080"
    ));

    @Test
    void testGenerateService() throws IOException {
        var model = new TypeScriptServiceModel();
        model.setName("TestServiceAPI");
        model.setClassName("de.test.typescript.client.type.TestServiceAPI");
        model.setBasePaths(List.of(new TypeScriptPathModel("/api/test", Collections.emptyList())));
        model.setMethods(List.of(
                method("test", "string")
        ));

        generator.generateService(model);

        var generatedService = fileGenerator.getFileContent("de.test.typescript.client.type", "TestServiceAPI");
        assertThat(generatedService.isPresent(), is(true));
        assertThat(generatedService.get(), is("""
                import { AsyncThunk, createAsyncThunk } from '@reduxjs/toolkit';
                import { useDispatch } from 'react-redux';
                import { useMemo } from 'react';
                import { State, ThunkOptions, Dispatch } from 'commons/thunk-options';
                import { mapJsonResponse, mapVoidResponse, mapStreamingResponse, url, mapStringResponse } from 'commons/react-service-commons';
                import { DownloadStreamDTO } from 'commons/download-stream.dto';
                import { testThunkConfig } from 'commons/service-commons';
                import { testPrepareHeaders } from 'auth/user-authenticator';

                function baseUrl(state: State): string {
                    return `http://localhost:8080/api/test`;
                }

                export const testThunk: AsyncThunk<string, undefined, ThunkConfig> = createAsyncThunk('TestServiceAPI/test', async function(arg: undefined, thunkAPI): Promise<string> {

                    const headers = new Headers();
                    testPrepareHeaders(headers, thunkAPI.getState());

                    return await fetch(url(`${baseUrl(thunkAPI.getState())}/test`), {
                        method: 'get',
                        credentials: 'include',
                        headers
                    }).then(res => mapStringResponse(res));
                }, ThunkOptions);

                /**
                 * Autogenerated service interface for the java class de.test.typescript.client.type.TestServiceAPI
                 */
                export interface TestServiceAPI {
                    test: () => Promise<string>;
                }

                /**
                 * Autogenerated service client for the java class de.test.typescript.client.type.TestServiceAPI
                 */
                export function useTestServiceAPI(): TestServiceAPI {
                    const dispatch: Dispatch = useDispatch();

                    return useMemo(() => {
                        return {
                            test: () => dispatch(testThunk()).unwrap()
                        };
                    }, [dispatch]);
                }
                """));
    }

    @Test
    void testGenerateUtilities() throws IOException {
        generator.generateUtilities();

        var generatedDownloadStreamDTO = fileGenerator.getFileContent("commons", "DownloadStreamDTO");
        assertThat(generatedDownloadStreamDTO.isPresent(), is(true));
        assertThat(generatedDownloadStreamDTO.get(), is("""
                interface DownloadStreamBaseDTO {
                    cancel: () => Promise<void>;
                    receivedBytes: number;
                    expectedBytes?: number;
                                
                }
                                
                export interface DownloadDoneDTO<T> extends DownloadStreamBaseDTO {
                    done: true;
                    value: T
                }
                                
                export interface DownloadProgressDTO extends DownloadStreamBaseDTO {
                    done: false;
                }
                                
                export type DownloadStreamDTO<T> = DownloadDoneDTO<T> | DownloadProgressDTO;                
                """));

        var generatedThunkOptions = fileGenerator.getFileContent("commons", "ThunkOptions");
        assertThat(generatedThunkOptions.isPresent(), is(true));
        assertThat(generatedThunkOptions.get(), is("""
                import { type AsyncThunkOptions } from '@reduxjs/toolkit';
                import { testThunkConfig, testErrorSerializer } from 'commons/service-commons';

                export const ThunkOptions: AsyncThunkOptions<unknown, testThunkConfig> = { testErrorSerializer };
                export type State = testThunkConfig['state'];
                export type Dispatch = testThunkConfig['dispatch'];        
                """));

        var generatedServiceCommons = fileGenerator.getFileContent("commons", "ReactServiceCommons");
        assertThat(generatedServiceCommons.isPresent(), is(true));
        assertThat(generatedServiceCommons.get(), is("""
                import { type DownloadStreamDTO } from './download-stream.dto';
                import { testErrorMapper } from 'commons/service-commons';

                export function url(pathname: string, searchParams: Record<string, string | number | boolean | undefined | null | {
                    toString: () => string
                }> = {}): URL {
                    const result = new URL(pathname);

                    for (const param of Object.keys(searchParams)) {
                        const value = searchParams[param];
                        if (typeof value === 'undefined' || value === null) {
                            continue;
                        }

                        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
                            result.searchParams.append(param, String(value));
                        } else {
                            result.searchParams.append(param, value.toString());
                        }
                    }

                    return result;
                }

                export async function mapJsonResponse<T>(res: Response): Promise<T> {
                    if (res.status !== 200) {
                        throw await testErrorMapper(res);
                    }

                    const contentType = res.headers.get('Content-Type');
                    if (contentType !== 'application/json') {
                        throw invalidResponseBodyError(contentType);
                    }

                    return await res.json() as T;
                }

                export async function mapVoidResponse(res: Response): Promise<void> {
                    if (res.status !== 200) {
                        throw await testErrorMapper(res);
                    }
                }

                export async function mapStringResponse(res: Response): Promise<string> {
                    if (res.status !== 200) {
                        throw await testErrorMapper(res);
                    }

                    const contentType = res.headers.get('Content-Type');
                    if (contentType === null || (contentType !== 'text/plain' && !contentType.startsWith('text/plain;'))) {
                        throw invalidResponseBodyError(contentType);
                    }

                    return await res.text();
                }

                export async function mapStreamingResponse(res: Response): Promise<DownloadStreamDTO<Uint8Array>> {
                    if (res.status !== 200) {
                        throw await testErrorMapper(res);
                    }

                    const contentLength = res.headers.get('Content-Length');
                    const expectedBytes = contentLength == null ? undefined : Number(contentLength);
                    if (res.body === null) {
                        throw new Error('Invalid response body: null');
                    }

                    const reader = res.body.getReader();
                    const stream = new DownloadStream(reader, expectedBytes);

                    stream.run();

                    return stream as DownloadStreamDTO<Uint8Array>;
                }

                function invalidResponseBodyError(actualContentType: string | null): Error {
                    return new Error(`Invalid response body: contentType is ${actualContentType ?? 'null'}`);
                }

                class DownloadStream {

                    done = false;
                    private pid = -1;
                    private canceled = false;
                    receivedBytes = 0;
                    private readonly chunks = Array<Uint8Array>();
                    value: Uint8Array | undefined;

                    constructor(private readonly reader: ReadableStreamDefaultReader<Uint8Array>,
                                readonly expectedBytes?: number,
                                private readonly timeout: number = 100) {

                    }

                    run(): void {
                        if (this.canceled) {
                            return;
                        }

                        this.pid = window.setTimeout(() => {
                            this.pid = -1;
                            this.readNext().then(() => this.run());
                        }, this.timeout);
                    }

                    private async readNext(): Promise<void> {
                        const result = await this.reader.read();

                        if (result.done) {
                            this.complete();
                            return;
                        }

                        this.chunks.push(result.value);
                        this.receivedBytes += result.value.length;
                    }

                    private complete(): void {
                        const value = new Uint8Array(this.receivedBytes);
                        let position = 0;
                        for (const chunk of this.chunks) {
                            value.set(chunk, position);
                            position += chunk.length;
                        }
                        this.value = value;
                        this.done = true;
                    }

                    async cancel(): Promise<void> {
                        this.canceled = true;

                        if (this.pid !== -1) {
                            window.clearTimeout(this.pid);
                        }

                        await this.reader.cancel();
                    }
                }
                """));
    }

    private TypeScriptServiceMethodModel method(String name, String returnType) {
        var model = new TypeScriptServiceMethodModel();
        model.setName(name);
        model.setReturnType(new TypeScriptTypeModel(returnType, false, Collections.emptySet()));
        model.setHttpMethod("GET");
        model.setPath(new TypeScriptPathModel("/" + name, Collections.emptyList()));
        model.setReturnTypeWrapper("Promise");
        model.setReturnTypeMapper("mapReturnType");
        model.setFormData(false);
        return model;
    }
}