<#ftl output_format="JavaScript">
<#-- @ftlvariable name="model" type="de.devx.project.commons.client.typescript.data.TypeScriptServiceModel" -->
<#-- @ftlvariable name="imports" type="java.util.Collection<de.devx.project.commons.client.typescript.data.TypeScriptImportModel>" -->
<#-- @ftlvariable name="prepareHeadersIdentifier" type="java.lang.String" -->
<#-- @ftlvariable name="testContextIdentifier" type="java.lang.String" -->
<#-- -->
<#macro setHeaderParam param>
<#-- @ftlvariable name="param" type="de.devx.project.commons.client.typescript.data.TypeScriptServiceMethodParameterModel" -->
<#if param.type.name == "string" || param.type.name == "string[]" >headers['${param.parameterName}'] = ${param.name};
<#elseif param.type.name == "number" || param.type.name == "boolean">headers['${param.parameterName}'] = String(${param.name});
<#elseif param.type.name == "number[]"  || param.type.name == "boolean[]" >headers['${param.parameterName}'] = ${param.name}.map(String).join(', ');
<#else>headers['${param.parameterName}'] = ${param.name}.toString();
</#if>
</#macro>
<#-- -->
<#-- -->
<#macro setQueryParam param>
<#-- @ftlvariable name="param" type="de.devx.project.commons.client.typescript.data.TypeScriptServiceMethodParameterModel" -->
<#if param.type.name == "string" || param.type.name == "number" || param.type.name == "boolean" || param.type.name == "string[]" || param.type.name == "number[]" || param.type.name == "boolean[]">params.${param.parameterName} = ${param.name};
<#else>params.${param.parameterName} = ${param.name}.toString();
</#if>
</#macro>
<#-- -->
<#-- -->
<#macro appendFormData param>
<#-- @ftlvariable name="param" type="de.devx.project.commons.client.typescript.data.TypeScriptServiceMethodParameterModel" -->
<#if param.type.name == 'File'>formData.append('${param.parameterName}', ${param.name}, ${param.name}.name);
<#elseif param.type.name == 'number'>formData.append('${param.parameterName}', String(${param.name}));
<#elseif param.type.name == 'string'>formData.append('${param.parameterName}', ${param.name});
<#else>formData.append('${param.parameterName}', ${param.name}.toString());
</#if>
</#macro>
<#-- -->
<#-- -->
<#macro url method>
<#-- @ftlvariable name="method" type="de.devx.project.commons.client.typescript.data.TypeScriptServiceMethodModel" -->
<#if method.path.path?has_content>${r"`${this.baseUrl(" + method.basePathParamNames?join(', ') + ")}" + method.path.path + "`"}<#else>this.baseUrl(${method.basePathParamNames?join(', ')})</#if></#macro>
<#-- -->
<#-- -->
<#macro methodParameterType method emptyParameterType>
<#-- @ftlvariable name="method" type="de.devx.project.commons.client.typescript.data.TypeScriptServiceMethodModel" -->
<#-- @ftlvariable name="emptyParameterType" type="java.lang.String" -->
<#if method.parameters?has_content>{ ${method.parameters?map(param -> param.name + param.optional?then("?", "") + ": " + param.type.name + param.optional?then(" | undefined", ""))?join(", ")} }<#else>${emptyParameterType}</#if></#macro>
<#-- -->
<#-- -->
import { APIRequestContext } from '@playwright/test';
<#list imports as import>
import { ${import.identifiers?join(", ")} } from '${import.path}';
</#list>

/**
 * Autogenerated service class for the java class ${model.className}
 */
export class ${model.name} {

    constructor(private readonly request: APIRequestContext,
                private readonly backendUrl: string) {
    }

    private baseUrl(${model.basePaths[0].params?map(baseUrlParam -> baseUrlParam + ": string | number")?join(", ")}): string {
        return <#if model.basePaths[0].path?has_content>${r"`${this.backendUrl}" + model.basePaths[0].path + "`"}<#else>this.backendUrl</#if>;
    }

    <#list model.methods as method>

    async ${method.name}(<#if testContextIdentifier?has_content>context: ${testContextIdentifier} | undefined, </#if>arg: <@methodParameterType method=method emptyParameterType="undefined"/>): <#if method.returnTypeWrapper == 'Observable'>Promise<Buffer><#else>${method.returnTypeWrapper}<${method.returnType.name}></#if> {
        <#if method.parameters?has_content>
            const { ${method.parameters?map(param -> param.name)?join(", ")} } = arg;
        </#if>

        const headers: Record<string, string> = {};
        <#if method.bodyParameter?has_content && !method.formData>
        headers['Content-Type'] = 'application/json';
        <#elseif method.formData>
        headers['Content-Type'] = 'application/x-www-form-urlencoded';
        </#if>
        <#if method.headerParams?has_content>
        <#list method.headerParams as headerParam>
        <#if headerParam.optional>if (typeof ${headerParam.name} !== 'undefined') {
        <@setHeaderParam param=headerParam></@setHeaderParam>    }
        <#else><@setHeaderParam param=headerParam></@setHeaderParam>
        </#if>
        </#list>
        </#if>
        <#if prepareHeadersIdentifier?has_content>${prepareHeadersIdentifier}(headers<#if testContextIdentifier?has_content>, context</#if>);</#if>

        <#if method.formData>
        const formData = new FormData();
        <#list method.queryParams as queryParam>
        <#if queryParam.optional>if (typeof ${queryParam.name} !== 'undefined') {
        <@appendFormData param=queryParam></@appendFormData>    }
        <#else><@appendFormData param=queryParam></@appendFormData>
        </#if>
        </#list>

        <#elseif method.queryParams?has_content && (method.httpMethod == "GET" || method.httpMethod == "DELETE")>
        const params: Record<string, string | number | boolean | Array<string | number | boolean>> = {};
        <#list method.queryParams as param>
        <#if param.optional>if (typeof ${param.name} !== 'undefined') {
            <@setQueryParam param=param></@setQueryParam>}
        <#else><@setQueryParam param=param></@setQueryParam>
        </#if>
        </#list>

        </#if>
        <#if method.returnType.name != "void">return </#if>await this.request.fetch(url(<@url method=method></@url><#if method.queryParams?has_content && (method.httpMethod == "GET" || method.httpMethod == "DELETE")>, params</#if>), {
            method: '${method.httpMethod?lower_case}',
            headers<#if method.formData || method.bodyParameter?has_content>,
            data: <#if method.bodyParameter?has_content && !method.formData>JSON.stringify(${method.bodyParameter})<#else>formData</#if>
        </#if>
        }).then(res => map<#if method.returnTypeWrapper == 'Observable'>StreamingResponse<#else><#switch method.returnType.name><#case 'void'>VoidResponse<#break><#case 'string'>StringResponse<#break><#case 'DownloadInfo'>StreamingResponse<#break><#default>JsonResponse<${method.returnType.name}></#switch></#if>(res));
    }
    </#list>
}