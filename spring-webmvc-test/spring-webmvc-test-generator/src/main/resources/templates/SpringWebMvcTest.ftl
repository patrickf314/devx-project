<#-- @ftlvariable name="test" type="de.devx.project.spring.webmvc.test.generator.data.SpringWebMvcTestModel" -->
<#-- @ftlvariable name="imports" type="java.util.Set<java.lang.String>" -->
<#-- @ftlvariable name="randomFunctions" type="de.devx.project.spring.webmvc.test.generator.data.SpringWebMvcRandomFunctionsModel" -->
package ${test.packageName};

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.jeasy.random.EasyRandom;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.HttpMethod;<#if test.activeProfile?has_content>
import org.springframework.test.context.ActiveProfiles;</#if>
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.web.context.WebApplicationContext;<#list imports as import>
import ${import};</#list><#if test.containsAsyncRequest()>
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;
import org.springframework.test.web.servlet.MvcResult;</#if><#if test.containsMultipartRequest()>

import java.nio.charset.StandardCharsets;</#if>

import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verify;<#if test.containsMultipartRequest()>
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.multipart;</#if><#if test.containsStandardRequest()>
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.request;</#if>
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest<#if test.activeProfile?has_content>
@ActiveProfiles({${test.activeProfile?map(p -> "\"" + p + "\"")?join(", ")}})</#if>
@ContextConfiguration(classes = {
    ${test.controller.mockName}.class<#list test.context as context>,
    ${context.mockName}.class</#list>
})
public class ${test.name} {

    protected final EasyRandom random;

    @Autowired
    protected ObjectMapper objectMapper;

    @Autowired
    protected WebApplicationContext webApplicationContext;

    @MockBean
    protected ${test.service.mockName} service;

    protected MockMvc mvc;

    protected ${test.name}(EasyRandom random) {
        this.random = random;
    }

    @BeforeEach
    void init() {
        mvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
    }<#list test.methods as method><#if method.parameters?has_content || method.returnType.mockName != 'void'>

    /**
     * Autogenerated test layout method for {@link ${test.controller.mockName}#${method.name}}
     *
     * @return the result of the {@link MockMvc} request
     * @throws Exception if an exceptions occurs
     */
    protected ResultActions ${method.name}() throws Exception {<#if method.returnType.mockName != 'void'>
        var ${method.name}Result = ${randomFunctions.getRandomFunctionName(method.returnType)};</#if><#list method.parameters as parameter>
        var ${parameter.name} = ${randomFunctions.getRandomFunctionName(parameter)};</#list>

        return ${method.name}(<#if method.returnType.mockName != 'void'>${method.name}Result<#if method.parameters?has_content>, </#if></#if>${method.parameters?map(p -> p.name)?join(", ")});
    }</#if>

    /**
     * Autogenerated test layout method for {@link ${test.controller.mockName}#${method.name}}
     *<#if method.returnType.mockName != 'void'>
     * @param ${method.name}Result an object which should be returned by the service mock</#if><#list method.parameters as parameter>
     * @param ${parameter.name} an object which should be passed to the controller by the request</#list>
     * @return the result of the {@link MockMvc} request
     * @throws Exception if an exceptions occurs
     */
    protected ResultActions ${method.name}(<#if method.returnType.mockName != 'void'>${method.returnType.fullName} ${method.name}Result<#if method.parameters?has_content>, </#if></#if>${method.parameters?map(p -> p.type.fullName + " " + p.name)?join(", ")}) throws Exception {<#if method.returnType.mockName != 'void'>
        mock${method.capitalizedName}ServiceCalls(${method.name}Result<#if method.parameters?has_content>, </#if>${method.parameters?map(p -> p.name)?join(", ")});</#if>

        var result = perform${method.capitalizedName}Request(${method.parameters?map(p -> p.name)?join(", ")})
                .andExpect(status().is(200))<#if method.returnType.mockName != 'void'>
                .andExpect(content().json(objectMapper.writeValueAsString(${method.name}Result)))</#if>;

        verify${method.capitalizedName}ServiceCalls(${method.parameters?map(p -> p.name)?join(", ")});
        return result;
    }

    protected ResultActions perform${method.capitalizedName}Request(${method.parameters?map(p -> p.type.fullName + " " + p.name)?join(", ")}) throws Exception {
        return mvc.perform(<#if method.multipartRequest>multipart<#else>request</#if>(HttpMethod.${method.httpMethod}, "${method.path.pattern}"<#if method.pathParams?has_content>, ${method.pathParams?map(p -> p.name)?join(", ")}</#if>)<#list method.fileParams as parameter>
                .file(${parameter.name})</#list><#list method.queryParams as parameter>
                .param("${parameter.httpName}", ${parameter.stringConversion})</#list><#list method.headerParams as parameter>
                .header("${parameter.httpName}", ${parameter.stringConversion})</#list><#if method.bodyParam?has_content>
                .contentType("application/json")
                .content(objectMapper.writeValueAsString(${method.bodyParam.name}))</#if>)<#if method.async>
            .andExpect(MockMvcResultMatchers.request().asyncStarted())
            .andDo(MvcResult::getAsyncResult)</#if>;
    }<#if method.returnType.mockName != 'void'>

    protected void mock${method.capitalizedName}ServiceCalls(${method.returnType.fullName} ${method.name}Result<#if method.parameters?has_content>, </#if>${method.parameters?map(p -> p.type.fullName + " " + p.name)?join(", ")}) throws Exception {<#if method.defaultServiceCall>
        when(service.${method.serviceMethodName}(${method.parameters?map(p -> p.name)?join(", ")})).thenReturn(${method.name}Result);<#else>
        throw new UnsupportedOperationException("Implement mock${method.capitalizedName}ServiceCall");</#if>
    }</#if>

    protected void verify${method.capitalizedName}ServiceCalls(${method.parameters?map(p -> p.type.fullName + " " + p.name)?join(", ")}) throws Exception {<#if method.defaultServiceCall>
        verify(service).${method.serviceMethodName}(${method.parameters?map(p -> p.name)?join(", ")});<#else>
        throw new UnsupportedOperationException("Implement verify${method.capitalizedName}ServiceCall");</#if>
    }</#list><#list randomFunctions.parametrizedRandomFunctions as method>

    protected ${method.type.fullName} ${method.name}() {
        throw new UnsupportedOperationException("Implement ${method.name}");
    }</#list>
}
