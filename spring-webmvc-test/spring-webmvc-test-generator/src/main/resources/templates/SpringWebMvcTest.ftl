<#-- @ftlvariable name="test" type="de.devx.project.spring.webmvc.test.generator.data.SpringWebMvcTestModel" -->
<#-- @ftlvariable name="imports" type="java.util.Set<java.lang.String>" -->
<#-- @ftlvariable name="parametrizedRandom" type="java.util.Collection<de.devx.project.spring.webmvc.test.generator.data.SpringWebMvcParametrizedRandomModel>" -->
<#-- @ftlvariable name="randomFunctions" type="java.util.Map<java.lang.String, java.lang.String>" -->
package ${test.packageName};

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.jeasy.random.EasyRandom;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.HttpMethod;<#if test.activeProfile?has_content>
import org.springframework.test.context.ActiveProfiles;</#if>
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.web.context.WebApplicationContext;<#list imports as import>
import ${import};</#list>

import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verify;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.request;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest<#if test.activeProfile?has_content>
@ActiveProfiles({${test.activeProfile?map(p -> "\"" + p + "\"")?join(", ")}})</#if>
@ContextConfiguration(classes = {
    ${test.controller.name}.class<#list test.context as context>,
    ${context.name}.class</#list>
})
public class ${test.name} {

    protected final EasyRandom random;

    @Autowired
    protected ObjectMapper objectMapper;

    @Autowired
    protected WebApplicationContext webApplicationContext;

    @MockBean
    protected ${test.service.name} service;

    protected MockMvc mvc;

    protected ${test.name}(EasyRandom random) {
        this.random = random;
    }

    @BeforeEach
    void init() {
        mvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
    }<#list test.methods as method><#if method.parameters?has_content || method.returnType.name != 'void'>

    /**
     * Autogenerated test layout method for {@link ${test.controller.name}#${method.name}}
     *
     * @return the result of the {@link MockMvc} request
     * @throws Exception if an exceptions occurs
     */
    protected ResultActions ${method.name}() throws Exception {<#if method.returnType.name != 'void'>
        var ${method.name}Result = ${randomFunctions[method.returnType.toString()]};</#if><#list method.parameters as parameter>
        var ${parameter.name} = ${randomFunctions[parameter.type.toString()]};</#list>

        return ${method.name}(<#if method.returnType.name != 'void'>${method.name}Result<#if method.parameters?has_content>, </#if></#if>${method.parameters?map(p -> p.name)?join(", ")});
    }</#if>

    /**
     * Autogenerated test layout method for {@link ${test.controller.name}#${method.name}}
     * <#if method.returnType.name != 'void'>
     * @param ${method.name}Result an object which should be returned by the service mock</#if><#list method.parameters as parameter>
     * @param ${parameter.name} an object which should be passed to the controller by the request</#list>
     * @return the result of the {@link MockMvc} request
     * @throws Exception if an exceptions occurs
     */
    protected ResultActions ${method.name}(<#if method.returnType.name != 'void'>${method.returnType.fullName} ${method.name}Result<#if method.parameters?has_content>, </#if></#if>${method.parameters?map(p -> p.type.fullName + " " + p.name)?join(", ")}) throws Exception {<#if method.returnType.name != 'void'>
        mock${method.capitalizedName}ServiceCalls(${method.name}Result<#if method.parameters?has_content>, </#if>${method.parameters?map(p -> p.name)?join(", ")});</#if>

        var result = perform${method.capitalizedName}Request(${method.parameters?map(p -> p.name)?join(", ")})
            .andExpect(status().is(200))<#if method.returnType.name != 'void'>
            .andExpect(content().json(objectMapper.writeValueAsString(${method.name}Result)))</#if>;

        verify${method.capitalizedName}ServiceCalls(${method.parameters?map(p -> p.name)?join(", ")});
        return result;
    }

    protected ResultActions perform${method.capitalizedName}Request(${method.parameters?map(p -> p.type.fullName + " " + p.name)?join(", ")}) throws Exception {
        return mvc.perform(request(HttpMethod.${method.httpMethod}, "${method.path.pattern}"<#if method.pathParams?has_content>, ${method.pathParams?map(p -> p.name)?join(", ")}</#if>)<#list method.queryParams as parameter>
            .queryParam("${parameter.name}", ${parameter.stringConversion})</#list><#list method.headerParams as parameter>
            .header("${parameter.name}", ${parameter.stringConversion})</#list><#if method.bodyParam?has_content>
            .contentType("application/json")
            .content(objectMapper.writeValueAsString(${method.bodyParam.name}))</#if>);
    }<#if method.returnType.name != 'void'>

    protected void mock${method.capitalizedName}ServiceCalls(${method.returnType.fullName} ${method.name}Result<#if method.parameters?has_content>, </#if>${method.parameters?map(p -> p.type.fullName + " " + p.name)?join(", ")}) throws Exception {<#if method.defaultServiceCall>
        when(service.${method.name}(${method.parameters?map(p -> p.name)?join(", ")})).thenReturn(${method.name}Result);<#else>
        throw new UnsupportedOperationException("Implement mock${method.capitalizedName}ServiceCall");</#if>
    }</#if>

    protected void verify${method.capitalizedName}ServiceCalls(${method.parameters?map(p -> p.type.fullName + " " + p.name)?join(", ")}) throws Exception {<#if method.defaultServiceCall>
        verify(service).${method.name}(${method.parameters?map(p -> p.name)?join(", ")});<#else>
        throw new UnsupportedOperationException("Implement verify${method.capitalizedName}ServiceCall");</#if>
    }</#list><#list parametrizedRandom as method>

    protected ${method.type.fullName} ${method.name}() {
        throw new UnsupportedOperationException("Implement ${method.name}");
    }</#list>
}
